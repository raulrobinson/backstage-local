{"version":3,"file":"static/9394.da099789.chunk.js","mappings":"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","sources":["webpack://app/../../node_modules/@graphiql/react/dist/Range.es.js","webpack://app/../../node_modules/@graphiql/react/dist/hint.es.js","webpack://app/../../node_modules/@graphiql/react/dist/onlineParser.es.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nclass CharacterStream {\n  constructor(sourceText) {\n    this.getStartOfToken = () => this._start;\n    this.getCurrentPosition = () => this._pos;\n    this.eol = () => this._sourceText.length === this._pos;\n    this.sol = () => this._pos === 0;\n    this.peek = () => {\n      return this._sourceText.charAt(this._pos) ? this._sourceText.charAt(this._pos) : null;\n    };\n    this.next = () => {\n      const char = this._sourceText.charAt(this._pos);\n      this._pos++;\n      return char;\n    };\n    this.eat = (pattern) => {\n      const isMatched = this._testNextCharacter(pattern);\n      if (isMatched) {\n        this._start = this._pos;\n        this._pos++;\n        return this._sourceText.charAt(this._pos - 1);\n      }\n      return void 0;\n    };\n    this.eatWhile = (match) => {\n      let isMatched = this._testNextCharacter(match);\n      let didEat = false;\n      if (isMatched) {\n        didEat = isMatched;\n        this._start = this._pos;\n      }\n      while (isMatched) {\n        this._pos++;\n        isMatched = this._testNextCharacter(match);\n        didEat = true;\n      }\n      return didEat;\n    };\n    this.eatSpace = () => this.eatWhile(/[\\s\\u00a0]/);\n    this.skipToEnd = () => {\n      this._pos = this._sourceText.length;\n    };\n    this.skipTo = (position) => {\n      this._pos = position;\n    };\n    this.match = (pattern, consume = true, caseFold = false) => {\n      let token = null;\n      let match = null;\n      if (typeof pattern === \"string\") {\n        const regex = new RegExp(pattern, caseFold ? \"i\" : \"g\");\n        match = regex.test(this._sourceText.substr(this._pos, pattern.length));\n        token = pattern;\n      } else if (pattern instanceof RegExp) {\n        match = this._sourceText.slice(this._pos).match(pattern);\n        token = match === null || match === void 0 ? void 0 : match[0];\n      }\n      if (match != null) {\n        if (typeof pattern === \"string\" || match instanceof Array && this._sourceText.startsWith(match[0], this._pos)) {\n          if (consume) {\n            this._start = this._pos;\n            if (token && token.length) {\n              this._pos += token.length;\n            }\n          }\n          return match;\n        }\n      }\n      return false;\n    };\n    this.backUp = (num) => {\n      this._pos -= num;\n    };\n    this.column = () => this._pos;\n    this.indentation = () => {\n      const match = this._sourceText.match(/\\s*/);\n      let indent = 0;\n      if (match && match.length !== 0) {\n        const whiteSpaces = match[0];\n        let pos = 0;\n        while (whiteSpaces.length > pos) {\n          if (whiteSpaces.charCodeAt(pos) === 9) {\n            indent += 2;\n          } else {\n            indent++;\n          }\n          pos++;\n        }\n      }\n      return indent;\n    };\n    this.current = () => this._sourceText.slice(this._start, this._pos);\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n  _testNextCharacter(pattern) {\n    const character = this._sourceText.charAt(this._pos);\n    let isMatched = false;\n    if (typeof pattern === \"string\") {\n      isMatched = character === pattern;\n    } else {\n      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n    }\n    return isMatched;\n  }\n}\n__name(CharacterStream, \"CharacterStream\");\nclass Range {\n  constructor(start, end) {\n    this.containsPosition = (position) => {\n      if (this.start.line === position.line) {\n        return this.start.character <= position.character;\n      } else if (this.end.line === position.line) {\n        return this.end.character >= position.character;\n      } else {\n        return this.start.line <= position.line && this.end.line >= position.line;\n      }\n    };\n    this.start = start;\n    this.end = end;\n  }\n  setStart(line, character) {\n    this.start = new Position(line, character);\n  }\n  setEnd(line, character) {\n    this.end = new Position(line, character);\n  }\n}\n__name(Range, \"Range\");\nclass Position {\n  constructor(line, character) {\n    this.lessThanOrEqualTo = (position) => this.line < position.line || this.line === position.line && this.character <= position.character;\n    this.line = line;\n    this.character = character;\n  }\n  setLine(line) {\n    this.line = line;\n  }\n  setCharacter(character) {\n    this.character = character;\n  }\n}\n__name(Position, \"Position\");\nexport { CharacterStream as C, Position as P, Range as R };\n","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { C as CodeMirror } from \"./codemirror.es.js\";\nimport \"./show-hint.es.js\";\nimport { isCompositeType, getNamedType, TypeNameMetaFieldDef as TypeNameMetaFieldDef$1, SchemaMetaFieldDef as SchemaMetaFieldDef$1, TypeMetaFieldDef as TypeMetaFieldDef$1, GraphQLEnumType, GraphQLBoolean, isInterfaceType, isAbstractType, assertAbstractType, doTypesOverlap, isInputType, DirectiveLocation, visit, parse, isListType, isNonNullType, GraphQLInterfaceType, GraphQLObjectType, Kind, GraphQLInputObjectType, getNullableType, GraphQLList } from \"graphql\";\nimport { R as RuleKinds, C as CompletionItemKind, I as InsertTextFormat } from \"./index.es.js\";\nimport { C as CharacterStream, P as Position } from \"./Range.es.js\";\nimport { o as onlineParser } from \"./onlineParser.es.js\";\nimport { S as SchemaMetaFieldDef, T as TypeMetaFieldDef, a as TypeNameMetaFieldDef } from \"./introspection.es.js\";\nimport \"react\";\nimport \"react-dom\";\nfunction getDefinitionState(tokenState) {\n  let definitionState;\n  forEachState(tokenState, (state) => {\n    switch (state.kind) {\n      case \"Query\":\n      case \"ShortQuery\":\n      case \"Mutation\":\n      case \"Subscription\":\n      case \"FragmentDefinition\":\n        definitionState = state;\n        break;\n    }\n  });\n  return definitionState;\n}\n__name(getDefinitionState, \"getDefinitionState\");\nfunction getFieldDef(schema, type, fieldName) {\n  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === type) {\n    return SchemaMetaFieldDef;\n  }\n  if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === type) {\n    return TypeMetaFieldDef;\n  }\n  if (fieldName === TypeNameMetaFieldDef.name && isCompositeType(type)) {\n    return TypeNameMetaFieldDef;\n  }\n  if (\"getFields\" in type) {\n    return type.getFields()[fieldName];\n  }\n  return null;\n}\n__name(getFieldDef, \"getFieldDef\");\nfunction forEachState(stack, fn) {\n  const reverseStateStack = [];\n  let state = stack;\n  while (state === null || state === void 0 ? void 0 : state.kind) {\n    reverseStateStack.push(state);\n    state = state.prevState;\n  }\n  for (let i = reverseStateStack.length - 1; i >= 0; i--) {\n    fn(reverseStateStack[i]);\n  }\n}\n__name(forEachState, \"forEachState\");\nfunction objectValues(object) {\n  const keys = Object.keys(object);\n  const len = keys.length;\n  const values = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    values[i] = object[keys[i]];\n  }\n  return values;\n}\n__name(objectValues, \"objectValues\");\nfunction hintList(token, list) {\n  return filterAndSortList(list, normalizeText(token.string));\n}\n__name(hintList, \"hintList\");\nfunction filterAndSortList(list, text) {\n  if (!text) {\n    return filterNonEmpty(list, (entry) => !entry.isDeprecated);\n  }\n  const byProximity = list.map((entry) => ({\n    proximity: getProximity(normalizeText(entry.label), text),\n    entry\n  }));\n  return filterNonEmpty(filterNonEmpty(byProximity, (pair) => pair.proximity <= 2), (pair) => !pair.entry.isDeprecated).sort((a, b) => (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.label.length - b.entry.label.length).map((pair) => pair.entry);\n}\n__name(filterAndSortList, \"filterAndSortList\");\nfunction filterNonEmpty(array, predicate) {\n  const filtered = array.filter(predicate);\n  return filtered.length === 0 ? array : filtered;\n}\n__name(filterNonEmpty, \"filterNonEmpty\");\nfunction normalizeText(text) {\n  return text.toLowerCase().replace(/\\W/g, \"\");\n}\n__name(normalizeText, \"normalizeText\");\nfunction getProximity(suggestion, text) {\n  let proximity = lexicalDistance(text, suggestion);\n  if (suggestion.length > text.length) {\n    proximity -= suggestion.length - text.length - 1;\n    proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;\n  }\n  return proximity;\n}\n__name(getProximity, \"getProximity\");\nfunction lexicalDistance(a, b) {\n  let i;\n  let j;\n  const d = [];\n  const aLength = a.length;\n  const bLength = b.length;\n  for (i = 0; i <= aLength; i++) {\n    d[i] = [i];\n  }\n  for (j = 1; j <= bLength; j++) {\n    d[0][j] = j;\n  }\n  for (i = 1; i <= aLength; i++) {\n    for (j = 1; j <= bLength; j++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n      }\n    }\n  }\n  return d[aLength][bLength];\n}\n__name(lexicalDistance, \"lexicalDistance\");\nconst SuggestionCommand = {\n  command: \"editor.action.triggerSuggest\",\n  title: \"Suggestions\"\n};\nconst collectFragmentDefs = /* @__PURE__ */ __name((op) => {\n  const externalFragments = [];\n  if (op) {\n    try {\n      visit(parse(op), {\n        FragmentDefinition(def) {\n          externalFragments.push(def);\n        }\n      });\n    } catch (_a) {\n      return [];\n    }\n  }\n  return externalFragments;\n}, \"collectFragmentDefs\");\nfunction getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs, options) {\n  var _a;\n  const opts = Object.assign(Object.assign({}, options), { schema });\n  const token = contextToken || getTokenAtPosition(queryText, cursor);\n  const state = token.state.kind === \"Invalid\" ? token.state.prevState : token.state;\n  if (!state) {\n    return [];\n  }\n  const kind = state.kind;\n  const step = state.step;\n  const typeInfo = getTypeInfo(schema, token.state);\n  if (kind === RuleKinds.DOCUMENT) {\n    return hintList(token, [\n      { label: \"query\", kind: CompletionItemKind.Function },\n      { label: \"mutation\", kind: CompletionItemKind.Function },\n      { label: \"subscription\", kind: CompletionItemKind.Function },\n      { label: \"fragment\", kind: CompletionItemKind.Function },\n      { label: \"{\", kind: CompletionItemKind.Constructor }\n    ]);\n  }\n  if (kind === RuleKinds.IMPLEMENTS || kind === RuleKinds.NAMED_TYPE && ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {\n    return getSuggestionsForImplements(token, state, schema, queryText, typeInfo);\n  }\n  if (kind === RuleKinds.SELECTION_SET || kind === RuleKinds.FIELD || kind === RuleKinds.ALIASED_FIELD) {\n    return getSuggestionsForFieldNames(token, typeInfo, opts);\n  }\n  if (kind === RuleKinds.ARGUMENTS || kind === RuleKinds.ARGUMENT && step === 0) {\n    const argDefs = typeInfo.argDefs;\n    if (argDefs) {\n      return hintList(token, argDefs.map((argDef) => {\n        var _a2;\n        return {\n          label: argDef.name,\n          insertText: argDef.name + \": \",\n          command: SuggestionCommand,\n          detail: String(argDef.type),\n          documentation: (_a2 = argDef.description) !== null && _a2 !== void 0 ? _a2 : void 0,\n          kind: CompletionItemKind.Variable,\n          type: argDef.type\n        };\n      }));\n    }\n  }\n  if (kind === RuleKinds.OBJECT_VALUE || kind === RuleKinds.OBJECT_FIELD && step === 0) {\n    if (typeInfo.objectFieldDefs) {\n      const objectFields = objectValues(typeInfo.objectFieldDefs);\n      const completionKind = kind === RuleKinds.OBJECT_VALUE ? CompletionItemKind.Value : CompletionItemKind.Field;\n      return hintList(token, objectFields.map((field) => {\n        var _a2;\n        return {\n          label: field.name,\n          detail: String(field.type),\n          documentation: (_a2 = field.description) !== null && _a2 !== void 0 ? _a2 : void 0,\n          kind: completionKind,\n          type: field.type\n        };\n      }));\n    }\n  }\n  if (kind === RuleKinds.ENUM_VALUE || kind === RuleKinds.LIST_VALUE && step === 1 || kind === RuleKinds.OBJECT_FIELD && step === 2 || kind === RuleKinds.ARGUMENT && step === 2) {\n    return getSuggestionsForInputValues(token, typeInfo, queryText, schema);\n  }\n  if (kind === RuleKinds.VARIABLE && step === 1) {\n    const namedInputType = getNamedType(typeInfo.inputType);\n    const variableDefinitions = getVariableCompletions(queryText, schema, token);\n    return hintList(token, variableDefinitions.filter((v) => v.detail === (namedInputType === null || namedInputType === void 0 ? void 0 : namedInputType.name)));\n  }\n  if (kind === RuleKinds.TYPE_CONDITION && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState != null && state.prevState.kind === RuleKinds.TYPE_CONDITION) {\n    return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema);\n  }\n  if (kind === RuleKinds.FRAGMENT_SPREAD && step === 1) {\n    return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, Array.isArray(fragmentDefs) ? fragmentDefs : collectFragmentDefs(fragmentDefs));\n  }\n  if (kind === RuleKinds.VARIABLE_DEFINITION && step === 2 || kind === RuleKinds.LIST_TYPE && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState && (state.prevState.kind === RuleKinds.VARIABLE_DEFINITION || state.prevState.kind === RuleKinds.LIST_TYPE || state.prevState.kind === RuleKinds.NON_NULL_TYPE)) {\n    return getSuggestionsForVariableDefinition(token, schema);\n  }\n  if (kind === RuleKinds.DIRECTIVE) {\n    return getSuggestionsForDirective(token, state, schema);\n  }\n  return [];\n}\n__name(getAutocompleteSuggestions, \"getAutocompleteSuggestions\");\nconst insertSuffix = ` {\n  $1\n}`;\nconst getInsertText = /* @__PURE__ */ __name((field) => {\n  const type = field.type;\n  if (isCompositeType(type)) {\n    return insertSuffix;\n  }\n  if (isListType(type) && isCompositeType(type.ofType)) {\n    return insertSuffix;\n  }\n  if (isNonNullType(type)) {\n    if (isCompositeType(type.ofType)) {\n      return insertSuffix;\n    }\n    if (isListType(type.ofType) && isCompositeType(type.ofType.ofType)) {\n      return insertSuffix;\n    }\n  }\n  return null;\n}, \"getInsertText\");\nfunction getSuggestionsForFieldNames(token, typeInfo, options) {\n  var _a;\n  if (typeInfo.parentType) {\n    const parentType = typeInfo.parentType;\n    let fields = [];\n    if (\"getFields\" in parentType) {\n      fields = objectValues(parentType.getFields());\n    }\n    if (isCompositeType(parentType)) {\n      fields.push(TypeNameMetaFieldDef$1);\n    }\n    if (parentType === ((_a = options === null || options === void 0 ? void 0 : options.schema) === null || _a === void 0 ? void 0 : _a.getQueryType())) {\n      fields.push(SchemaMetaFieldDef$1, TypeMetaFieldDef$1);\n    }\n    return hintList(token, fields.map((field, index) => {\n      var _a2;\n      const suggestion = {\n        sortText: String(index) + field.name,\n        label: field.name,\n        detail: String(field.type),\n        documentation: (_a2 = field.description) !== null && _a2 !== void 0 ? _a2 : void 0,\n        deprecated: Boolean(field.deprecationReason),\n        isDeprecated: Boolean(field.deprecationReason),\n        deprecationReason: field.deprecationReason,\n        kind: CompletionItemKind.Field,\n        type: field.type\n      };\n      const insertText = getInsertText(field);\n      if (insertText) {\n        suggestion.insertText = field.name + insertText;\n        suggestion.insertTextFormat = InsertTextFormat.Snippet;\n        suggestion.command = SuggestionCommand;\n      }\n      return suggestion;\n    }));\n  }\n  return [];\n}\n__name(getSuggestionsForFieldNames, \"getSuggestionsForFieldNames\");\nfunction getSuggestionsForInputValues(token, typeInfo, queryText, schema) {\n  const namedInputType = getNamedType(typeInfo.inputType);\n  const queryVariables = getVariableCompletions(queryText, schema, token).filter((v) => v.detail === namedInputType.name);\n  if (namedInputType instanceof GraphQLEnumType) {\n    const values = namedInputType.getValues();\n    return hintList(token, values.map((value) => {\n      var _a;\n      return {\n        label: value.name,\n        detail: String(namedInputType),\n        documentation: (_a = value.description) !== null && _a !== void 0 ? _a : void 0,\n        deprecated: Boolean(value.deprecationReason),\n        isDeprecated: Boolean(value.deprecationReason),\n        deprecationReason: value.deprecationReason,\n        kind: CompletionItemKind.EnumMember,\n        type: namedInputType\n      };\n    }).concat(queryVariables));\n  } else if (namedInputType === GraphQLBoolean) {\n    return hintList(token, queryVariables.concat([\n      {\n        label: \"true\",\n        detail: String(GraphQLBoolean),\n        documentation: \"Not false.\",\n        kind: CompletionItemKind.Variable,\n        type: GraphQLBoolean\n      },\n      {\n        label: \"false\",\n        detail: String(GraphQLBoolean),\n        documentation: \"Not true.\",\n        kind: CompletionItemKind.Variable,\n        type: GraphQLBoolean\n      }\n    ]));\n  }\n  return queryVariables;\n}\n__name(getSuggestionsForInputValues, \"getSuggestionsForInputValues\");\nfunction getSuggestionsForImplements(token, tokenState, schema, documentText, typeInfo) {\n  if (tokenState.needsSeparator) {\n    return [];\n  }\n  const typeMap = schema.getTypeMap();\n  const schemaInterfaces = objectValues(typeMap).filter(isInterfaceType);\n  const schemaInterfaceNames = schemaInterfaces.map(({ name }) => name);\n  const inlineInterfaces = /* @__PURE__ */ new Set();\n  runOnlineParser(documentText, (_, state) => {\n    var _a, _b, _c, _d, _e;\n    if (state.name) {\n      if (state.kind === RuleKinds.INTERFACE_DEF && !schemaInterfaceNames.includes(state.name)) {\n        inlineInterfaces.add(state.name);\n      }\n      if (state.kind === RuleKinds.NAMED_TYPE && ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {\n        if (typeInfo.interfaceDef) {\n          const existingType = (_b = typeInfo.interfaceDef) === null || _b === void 0 ? void 0 : _b.getInterfaces().find(({ name }) => name === state.name);\n          if (existingType) {\n            return;\n          }\n          const type = schema.getType(state.name);\n          const interfaceConfig = (_c = typeInfo.interfaceDef) === null || _c === void 0 ? void 0 : _c.toConfig();\n          typeInfo.interfaceDef = new GraphQLInterfaceType(Object.assign(Object.assign({}, interfaceConfig), { interfaces: [\n            ...interfaceConfig.interfaces,\n            type || new GraphQLInterfaceType({ name: state.name, fields: {} })\n          ] }));\n        } else if (typeInfo.objectTypeDef) {\n          const existingType = (_d = typeInfo.objectTypeDef) === null || _d === void 0 ? void 0 : _d.getInterfaces().find(({ name }) => name === state.name);\n          if (existingType) {\n            return;\n          }\n          const type = schema.getType(state.name);\n          const objectTypeConfig = (_e = typeInfo.objectTypeDef) === null || _e === void 0 ? void 0 : _e.toConfig();\n          typeInfo.objectTypeDef = new GraphQLObjectType(Object.assign(Object.assign({}, objectTypeConfig), { interfaces: [\n            ...objectTypeConfig.interfaces,\n            type || new GraphQLInterfaceType({ name: state.name, fields: {} })\n          ] }));\n        }\n      }\n    }\n  });\n  const currentTypeToExtend = typeInfo.interfaceDef || typeInfo.objectTypeDef;\n  const siblingInterfaces = (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.getInterfaces()) || [];\n  const siblingInterfaceNames = siblingInterfaces.map(({ name }) => name);\n  const possibleInterfaces = schemaInterfaces.concat([...inlineInterfaces].map((name) => ({ name }))).filter(({ name }) => name !== (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.name) && !siblingInterfaceNames.includes(name));\n  return hintList(token, possibleInterfaces.map((type) => {\n    const result = {\n      label: type.name,\n      kind: CompletionItemKind.Interface,\n      type\n    };\n    if (type === null || type === void 0 ? void 0 : type.description) {\n      result.documentation = type.description;\n    }\n    return result;\n  }));\n}\n__name(getSuggestionsForImplements, \"getSuggestionsForImplements\");\nfunction getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind) {\n  let possibleTypes;\n  if (typeInfo.parentType) {\n    if (isAbstractType(typeInfo.parentType)) {\n      const abstractType = assertAbstractType(typeInfo.parentType);\n      const possibleObjTypes = schema.getPossibleTypes(abstractType);\n      const possibleIfaceMap = /* @__PURE__ */ Object.create(null);\n      possibleObjTypes.forEach((type) => {\n        type.getInterfaces().forEach((iface) => {\n          possibleIfaceMap[iface.name] = iface;\n        });\n      });\n      possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));\n    } else {\n      possibleTypes = [typeInfo.parentType];\n    }\n  } else {\n    const typeMap = schema.getTypeMap();\n    possibleTypes = objectValues(typeMap).filter(isCompositeType);\n  }\n  return hintList(token, possibleTypes.map((type) => {\n    const namedType = getNamedType(type);\n    return {\n      label: String(type),\n      documentation: (namedType === null || namedType === void 0 ? void 0 : namedType.description) || \"\",\n      kind: CompletionItemKind.Field\n    };\n  }));\n}\n__name(getSuggestionsForFragmentTypeConditions, \"getSuggestionsForFragmentTypeConditions\");\nfunction getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs) {\n  if (!queryText) {\n    return [];\n  }\n  const typeMap = schema.getTypeMap();\n  const defState = getDefinitionState(token.state);\n  const fragments = getFragmentDefinitions(queryText);\n  if (fragmentDefs && fragmentDefs.length > 0) {\n    fragments.push(...fragmentDefs);\n  }\n  const relevantFrags = fragments.filter((frag) => typeMap[frag.typeCondition.name.value] && !(defState && defState.kind === RuleKinds.FRAGMENT_DEFINITION && defState.name === frag.name.value) && isCompositeType(typeInfo.parentType) && isCompositeType(typeMap[frag.typeCondition.name.value]) && doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));\n  return hintList(token, relevantFrags.map((frag) => ({\n    label: frag.name.value,\n    detail: String(typeMap[frag.typeCondition.name.value]),\n    documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,\n    kind: CompletionItemKind.Field,\n    type: typeMap[frag.typeCondition.name.value]\n  })));\n}\n__name(getSuggestionsForFragmentSpread, \"getSuggestionsForFragmentSpread\");\nconst getParentDefinition = /* @__PURE__ */ __name((state, kind) => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n  if (((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) === kind) {\n    return state.prevState;\n  }\n  if (((_c = (_b = state.prevState) === null || _b === void 0 ? void 0 : _b.prevState) === null || _c === void 0 ? void 0 : _c.kind) === kind) {\n    return state.prevState.prevState;\n  }\n  if (((_f = (_e = (_d = state.prevState) === null || _d === void 0 ? void 0 : _d.prevState) === null || _e === void 0 ? void 0 : _e.prevState) === null || _f === void 0 ? void 0 : _f.kind) === kind) {\n    return state.prevState.prevState.prevState;\n  }\n  if (((_k = (_j = (_h = (_g = state.prevState) === null || _g === void 0 ? void 0 : _g.prevState) === null || _h === void 0 ? void 0 : _h.prevState) === null || _j === void 0 ? void 0 : _j.prevState) === null || _k === void 0 ? void 0 : _k.kind) === kind) {\n    return state.prevState.prevState.prevState.prevState;\n  }\n}, \"getParentDefinition\");\nfunction getVariableCompletions(queryText, schema, token) {\n  let variableName = null;\n  let variableType;\n  const definitions = /* @__PURE__ */ Object.create({});\n  runOnlineParser(queryText, (_, state) => {\n    if ((state === null || state === void 0 ? void 0 : state.kind) === RuleKinds.VARIABLE && state.name) {\n      variableName = state.name;\n    }\n    if ((state === null || state === void 0 ? void 0 : state.kind) === RuleKinds.NAMED_TYPE && variableName) {\n      const parentDefinition = getParentDefinition(state, RuleKinds.TYPE);\n      if (parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type) {\n        variableType = schema.getType(parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type);\n      }\n    }\n    if (variableName && variableType) {\n      if (!definitions[variableName]) {\n        definitions[variableName] = {\n          detail: variableType.toString(),\n          insertText: token.string === \"$\" ? variableName : \"$\" + variableName,\n          label: variableName,\n          type: variableType,\n          kind: CompletionItemKind.Variable\n        };\n        variableName = null;\n        variableType = null;\n      }\n    }\n  });\n  return objectValues(definitions);\n}\n__name(getVariableCompletions, \"getVariableCompletions\");\nfunction getFragmentDefinitions(queryText) {\n  const fragmentDefs = [];\n  runOnlineParser(queryText, (_, state) => {\n    if (state.kind === RuleKinds.FRAGMENT_DEFINITION && state.name && state.type) {\n      fragmentDefs.push({\n        kind: RuleKinds.FRAGMENT_DEFINITION,\n        name: {\n          kind: Kind.NAME,\n          value: state.name\n        },\n        selectionSet: {\n          kind: RuleKinds.SELECTION_SET,\n          selections: []\n        },\n        typeCondition: {\n          kind: RuleKinds.NAMED_TYPE,\n          name: {\n            kind: Kind.NAME,\n            value: state.type\n          }\n        }\n      });\n    }\n  });\n  return fragmentDefs;\n}\n__name(getFragmentDefinitions, \"getFragmentDefinitions\");\nfunction getSuggestionsForVariableDefinition(token, schema, _kind) {\n  const inputTypeMap = schema.getTypeMap();\n  const inputTypes = objectValues(inputTypeMap).filter(isInputType);\n  return hintList(token, inputTypes.map((type) => ({\n    label: type.name,\n    documentation: type.description,\n    kind: CompletionItemKind.Variable\n  })));\n}\n__name(getSuggestionsForVariableDefinition, \"getSuggestionsForVariableDefinition\");\nfunction getSuggestionsForDirective(token, state, schema, _kind) {\n  var _a;\n  if ((_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind) {\n    const directives = schema.getDirectives().filter((directive) => canUseDirective(state.prevState, directive));\n    return hintList(token, directives.map((directive) => ({\n      label: directive.name,\n      documentation: directive.description || \"\",\n      kind: CompletionItemKind.Function\n    })));\n  }\n  return [];\n}\n__name(getSuggestionsForDirective, \"getSuggestionsForDirective\");\nfunction getTokenAtPosition(queryText, cursor) {\n  let styleAtCursor = null;\n  let stateAtCursor = null;\n  let stringAtCursor = null;\n  const token = runOnlineParser(queryText, (stream, state, style, index) => {\n    if (index === cursor.line) {\n      if (stream.getCurrentPosition() >= cursor.character) {\n        styleAtCursor = style;\n        stateAtCursor = Object.assign({}, state);\n        stringAtCursor = stream.current();\n        return \"BREAK\";\n      }\n    }\n  });\n  return {\n    start: token.start,\n    end: token.end,\n    string: stringAtCursor || token.string,\n    state: stateAtCursor || token.state,\n    style: styleAtCursor || token.style\n  };\n}\n__name(getTokenAtPosition, \"getTokenAtPosition\");\nfunction runOnlineParser(queryText, callback) {\n  const lines = queryText.split(\"\\n\");\n  const parser = onlineParser();\n  let state = parser.startState();\n  let style = \"\";\n  let stream = new CharacterStream(\"\");\n  for (let i = 0; i < lines.length; i++) {\n    stream = new CharacterStream(lines[i]);\n    while (!stream.eol()) {\n      style = parser.token(stream, state);\n      const code = callback(stream, state, style, i);\n      if (code === \"BREAK\") {\n        break;\n      }\n    }\n    callback(stream, state, style, i);\n    if (!state.kind) {\n      state = parser.startState();\n    }\n  }\n  return {\n    start: stream.getStartOfToken(),\n    end: stream.getCurrentPosition(),\n    string: stream.current(),\n    state,\n    style\n  };\n}\n__name(runOnlineParser, \"runOnlineParser\");\nfunction canUseDirective(state, directive) {\n  var _a;\n  if (!state || !state.kind) {\n    return false;\n  }\n  const kind = state.kind;\n  const locations = directive.locations;\n  switch (kind) {\n    case RuleKinds.QUERY:\n      return locations.indexOf(DirectiveLocation.QUERY) !== -1;\n    case RuleKinds.MUTATION:\n      return locations.indexOf(DirectiveLocation.MUTATION) !== -1;\n    case RuleKinds.SUBSCRIPTION:\n      return locations.indexOf(DirectiveLocation.SUBSCRIPTION) !== -1;\n    case RuleKinds.FIELD:\n    case RuleKinds.ALIASED_FIELD:\n      return locations.indexOf(DirectiveLocation.FIELD) !== -1;\n    case RuleKinds.FRAGMENT_DEFINITION:\n      return locations.indexOf(DirectiveLocation.FRAGMENT_DEFINITION) !== -1;\n    case RuleKinds.FRAGMENT_SPREAD:\n      return locations.indexOf(DirectiveLocation.FRAGMENT_SPREAD) !== -1;\n    case RuleKinds.INLINE_FRAGMENT:\n      return locations.indexOf(DirectiveLocation.INLINE_FRAGMENT) !== -1;\n    case RuleKinds.SCHEMA_DEF:\n      return locations.indexOf(DirectiveLocation.SCHEMA) !== -1;\n    case RuleKinds.SCALAR_DEF:\n      return locations.indexOf(DirectiveLocation.SCALAR) !== -1;\n    case RuleKinds.OBJECT_TYPE_DEF:\n      return locations.indexOf(DirectiveLocation.OBJECT) !== -1;\n    case RuleKinds.FIELD_DEF:\n      return locations.indexOf(DirectiveLocation.FIELD_DEFINITION) !== -1;\n    case RuleKinds.INTERFACE_DEF:\n      return locations.indexOf(DirectiveLocation.INTERFACE) !== -1;\n    case RuleKinds.UNION_DEF:\n      return locations.indexOf(DirectiveLocation.UNION) !== -1;\n    case RuleKinds.ENUM_DEF:\n      return locations.indexOf(DirectiveLocation.ENUM) !== -1;\n    case RuleKinds.ENUM_VALUE:\n      return locations.indexOf(DirectiveLocation.ENUM_VALUE) !== -1;\n    case RuleKinds.INPUT_DEF:\n      return locations.indexOf(DirectiveLocation.INPUT_OBJECT) !== -1;\n    case RuleKinds.INPUT_VALUE_DEF:\n      const prevStateKind = (_a = state.prevState) === null || _a === void 0 ? void 0 : _a.kind;\n      switch (prevStateKind) {\n        case RuleKinds.ARGUMENTS_DEF:\n          return locations.indexOf(DirectiveLocation.ARGUMENT_DEFINITION) !== -1;\n        case RuleKinds.INPUT_DEF:\n          return locations.indexOf(DirectiveLocation.INPUT_FIELD_DEFINITION) !== -1;\n      }\n  }\n  return false;\n}\n__name(canUseDirective, \"canUseDirective\");\nfunction getTypeInfo(schema, tokenState) {\n  let argDef;\n  let argDefs;\n  let directiveDef;\n  let enumValue;\n  let fieldDef;\n  let inputType;\n  let objectTypeDef;\n  let objectFieldDefs;\n  let parentType;\n  let type;\n  let interfaceDef;\n  forEachState(tokenState, (state) => {\n    var _a;\n    switch (state.kind) {\n      case RuleKinds.QUERY:\n      case \"ShortQuery\":\n        type = schema.getQueryType();\n        break;\n      case RuleKinds.MUTATION:\n        type = schema.getMutationType();\n        break;\n      case RuleKinds.SUBSCRIPTION:\n        type = schema.getSubscriptionType();\n        break;\n      case RuleKinds.INLINE_FRAGMENT:\n      case RuleKinds.FRAGMENT_DEFINITION:\n        if (state.type) {\n          type = schema.getType(state.type);\n        }\n        break;\n      case RuleKinds.FIELD:\n      case RuleKinds.ALIASED_FIELD: {\n        if (!type || !state.name) {\n          fieldDef = null;\n        } else {\n          fieldDef = parentType ? getFieldDef(schema, parentType, state.name) : null;\n          type = fieldDef ? fieldDef.type : null;\n        }\n        break;\n      }\n      case RuleKinds.SELECTION_SET:\n        parentType = getNamedType(type);\n        break;\n      case RuleKinds.DIRECTIVE:\n        directiveDef = state.name ? schema.getDirective(state.name) : null;\n        break;\n      case RuleKinds.INTERFACE_DEF:\n        if (state.name) {\n          objectTypeDef = null;\n          interfaceDef = new GraphQLInterfaceType({\n            name: state.name,\n            interfaces: [],\n            fields: {}\n          });\n        }\n        break;\n      case RuleKinds.OBJECT_TYPE_DEF:\n        if (state.name) {\n          interfaceDef = null;\n          objectTypeDef = new GraphQLObjectType({\n            name: state.name,\n            interfaces: [],\n            fields: {}\n          });\n        }\n        break;\n      case RuleKinds.ARGUMENTS: {\n        if (!state.prevState) {\n          argDefs = null;\n        } else {\n          switch (state.prevState.kind) {\n            case RuleKinds.FIELD:\n              argDefs = fieldDef && fieldDef.args;\n              break;\n            case RuleKinds.DIRECTIVE:\n              argDefs = directiveDef && directiveDef.args;\n              break;\n            case RuleKinds.ALIASED_FIELD: {\n              const name = (_a = state.prevState) === null || _a === void 0 ? void 0 : _a.name;\n              if (!name) {\n                argDefs = null;\n                break;\n              }\n              const field = parentType ? getFieldDef(schema, parentType, name) : null;\n              if (!field) {\n                argDefs = null;\n                break;\n              }\n              argDefs = field.args;\n              break;\n            }\n            default:\n              argDefs = null;\n              break;\n          }\n        }\n        break;\n      }\n      case RuleKinds.ARGUMENT:\n        if (argDefs) {\n          for (let i = 0; i < argDefs.length; i++) {\n            if (argDefs[i].name === state.name) {\n              argDef = argDefs[i];\n              break;\n            }\n          }\n        }\n        inputType = argDef === null || argDef === void 0 ? void 0 : argDef.type;\n        break;\n      case RuleKinds.ENUM_VALUE:\n        const enumType = getNamedType(inputType);\n        enumValue = enumType instanceof GraphQLEnumType ? enumType.getValues().find((val) => val.value === state.name) : null;\n        break;\n      case RuleKinds.LIST_VALUE:\n        const nullableType = getNullableType(inputType);\n        inputType = nullableType instanceof GraphQLList ? nullableType.ofType : null;\n        break;\n      case RuleKinds.OBJECT_VALUE:\n        const objectType = getNamedType(inputType);\n        objectFieldDefs = objectType instanceof GraphQLInputObjectType ? objectType.getFields() : null;\n        break;\n      case RuleKinds.OBJECT_FIELD:\n        const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;\n        inputType = objectField === null || objectField === void 0 ? void 0 : objectField.type;\n        break;\n      case RuleKinds.NAMED_TYPE:\n        if (state.name) {\n          type = schema.getType(state.name);\n        }\n        break;\n    }\n  });\n  return {\n    argDef,\n    argDefs,\n    directiveDef,\n    enumValue,\n    fieldDef,\n    inputType,\n    objectFieldDefs,\n    parentType,\n    type,\n    interfaceDef,\n    objectTypeDef\n  };\n}\n__name(getTypeInfo, \"getTypeInfo\");\nCodeMirror.registerHelper(\"hint\", \"graphql\", (editor, options) => {\n  const schema = options.schema;\n  if (!schema) {\n    return;\n  }\n  const cur = editor.getCursor();\n  const token = editor.getTokenAt(cur);\n  const tokenStart = token.type !== null && /\"|\\w/.test(token.string[0]) ? token.start : token.end;\n  const position = new Position(cur.line, tokenStart);\n  const rawResults = getAutocompleteSuggestions(schema, editor.getValue(), position, token, options.externalFragments);\n  const results = {\n    list: rawResults.map((item) => ({\n      text: item.label,\n      type: item.type,\n      description: item.documentation,\n      isDeprecated: item.isDeprecated,\n      deprecationReason: item.deprecationReason\n    })),\n    from: { line: cur.line, ch: tokenStart },\n    to: { line: cur.line, ch: token.end }\n  };\n  if ((results === null || results === void 0 ? void 0 : results.list) && results.list.length > 0) {\n    results.from = CodeMirror.Pos(results.from.line, results.from.ch);\n    results.to = CodeMirror.Pos(results.to.line, results.to.ch);\n    CodeMirror.signal(editor, \"hasCompletion\", editor, results, token);\n  }\n  return results;\n});\n","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { i as isIgnored, L as LexRules, P as ParseRules } from \"./index.es.js\";\nimport { Kind } from \"graphql\";\nfunction onlineParser(options = {\n  eatWhitespace: (stream) => stream.eatWhile(isIgnored),\n  lexRules: LexRules,\n  parseRules: ParseRules,\n  editorConfig: {}\n}) {\n  return {\n    startState() {\n      const initialState = {\n        level: 0,\n        step: 0,\n        name: null,\n        kind: null,\n        type: null,\n        rule: null,\n        needsSeparator: false,\n        prevState: null\n      };\n      pushRule(options.parseRules, initialState, Kind.DOCUMENT);\n      return initialState;\n    },\n    token(stream, state) {\n      return getToken(stream, state, options);\n    }\n  };\n}\n__name(onlineParser, \"onlineParser\");\nfunction getToken(stream, state, options) {\n  var _a;\n  if (state.inBlockstring) {\n    if (stream.match(/.*\"\"\"/)) {\n      state.inBlockstring = false;\n      return \"string\";\n    } else {\n      stream.skipToEnd();\n      return \"string\";\n    }\n  }\n  const { lexRules, parseRules, eatWhitespace, editorConfig } = options;\n  if (state.rule && state.rule.length === 0) {\n    popRule(state);\n  } else if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state, true);\n  }\n  if (stream.sol()) {\n    const tabSize = (editorConfig === null || editorConfig === void 0 ? void 0 : editorConfig.tabSize) || 2;\n    state.indentLevel = Math.floor(stream.indentation() / tabSize);\n  }\n  if (eatWhitespace(stream)) {\n    return \"ws\";\n  }\n  const token = lex(lexRules, stream);\n  if (!token) {\n    const matchedSomething = stream.match(/\\S+/);\n    if (!matchedSomething) {\n      stream.match(/\\s/);\n    }\n    pushRule(SpecialParseRules, state, \"Invalid\");\n    return \"invalidchar\";\n  }\n  if (token.kind === \"Comment\") {\n    pushRule(SpecialParseRules, state, \"Comment\");\n    return \"comment\";\n  }\n  const backupState = assign({}, state);\n  if (token.kind === \"Punctuation\") {\n    if (/^[{([]/.test(token.value)) {\n      if (state.indentLevel !== void 0) {\n        state.levels = (state.levels || []).concat(state.indentLevel + 1);\n      }\n    } else if (/^[})\\]]/.test(token.value)) {\n      const levels = state.levels = (state.levels || []).slice(0, -1);\n      if (state.indentLevel) {\n        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n          state.indentLevel = levels[levels.length - 1];\n        }\n      }\n    }\n  }\n  while (state.rule) {\n    let expected = typeof state.rule === \"function\" ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];\n    if (state.needsSeparator) {\n      expected = expected === null || expected === void 0 ? void 0 : expected.separator;\n    }\n    if (expected) {\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      }\n      if (typeof expected === \"string\") {\n        pushRule(parseRules, state, expected);\n        continue;\n      }\n      if ((_a = expected.match) === null || _a === void 0 ? void 0 : _a.call(expected, token)) {\n        if (expected.update) {\n          expected.update(state, token);\n        }\n        if (token.kind === \"Punctuation\") {\n          advanceRule(state, true);\n        } else {\n          state.needsAdvance = true;\n        }\n        return expected.style;\n      }\n    }\n    unsuccessful(state);\n  }\n  assign(state, backupState);\n  pushRule(SpecialParseRules, state, \"Invalid\");\n  return \"invalidchar\";\n}\n__name(getToken, \"getToken\");\nfunction assign(to, from) {\n  const keys = Object.keys(from);\n  for (let i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n  return to;\n}\n__name(assign, \"assign\");\nconst SpecialParseRules = {\n  Invalid: [],\n  Comment: []\n};\nfunction pushRule(rules, state, ruleKind) {\n  if (!rules[ruleKind]) {\n    throw new TypeError(\"Unknown rule: \" + ruleKind);\n  }\n  state.prevState = Object.assign({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = rules[ruleKind];\n  state.step = 0;\n  state.needsSeparator = false;\n}\n__name(pushRule, \"pushRule\");\nfunction popRule(state) {\n  if (!state.prevState) {\n    return;\n  }\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.needsSeparator = state.prevState.needsSeparator;\n  state.prevState = state.prevState.prevState;\n}\n__name(popRule, \"popRule\");\nfunction advanceRule(state, successful) {\n  var _a;\n  if (isList(state) && state.rule) {\n    const step = state.rule[state.step];\n    if (step.separator) {\n      const separator = step.separator;\n      state.needsSeparator = !state.needsSeparator;\n      if (!state.needsSeparator && separator.ofRule) {\n        return;\n      }\n    }\n    if (successful) {\n      return;\n    }\n  }\n  state.needsSeparator = false;\n  state.step++;\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n    if (state.rule) {\n      if (isList(state)) {\n        if ((_a = state.rule) === null || _a === void 0 ? void 0 : _a[state.step].separator) {\n          state.needsSeparator = !state.needsSeparator;\n        }\n      } else {\n        state.needsSeparator = false;\n        state.step++;\n      }\n    }\n  }\n}\n__name(advanceRule, \"advanceRule\");\nfunction isList(state) {\n  const step = Array.isArray(state.rule) && typeof state.rule[state.step] !== \"string\" && state.rule[state.step];\n  return step && step.isList;\n}\n__name(isList, \"isList\");\nfunction unsuccessful(state) {\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  }\n  if (state.rule) {\n    advanceRule(state, false);\n  }\n}\n__name(unsuccessful, \"unsuccessful\");\nfunction lex(lexRules, stream) {\n  const kinds = Object.keys(lexRules);\n  for (let i = 0; i < kinds.length; i++) {\n    const match = stream.match(lexRules[kinds[i]]);\n    if (match && match instanceof Array) {\n      return { kind: kinds[i], value: match[0] };\n    }\n  }\n}\n__name(lex, \"lex\");\nexport { onlineParser as o };\n"],"names":["__defProp","__name","target","value","CharacterStream","sourceText","char","pattern","match","isMatched","didEat","position","consume","caseFold","token","num","indent","whiteSpaces","pos","character","Range","start","end","line","Position","getDefinitionState","tokenState","definitionState","forEachState","state","getFieldDef","schema","type","fieldName","stack","fn","reverseStateStack","i","objectValues","object","keys","len","values","hintList","list","filterAndSortList","normalizeText","text","filterNonEmpty","entry","byProximity","getProximity","pair","a","b","array","predicate","filtered","suggestion","proximity","lexicalDistance","j","d","aLength","bLength","cost","SuggestionCommand","collectFragmentDefs","op","externalFragments","def","getAutocompleteSuggestions","queryText","cursor","contextToken","fragmentDefs","options","_a","opts","getTokenAtPosition","kind","step","typeInfo","getTypeInfo","getSuggestionsForImplements","getSuggestionsForFieldNames","argDefs","argDef","_a2","objectFields","completionKind","field","getSuggestionsForInputValues","namedInputType","variableDefinitions","getVariableCompletions","v","getSuggestionsForFragmentTypeConditions","getSuggestionsForFragmentSpread","getSuggestionsForVariableDefinition","getSuggestionsForDirective","insertSuffix","getInsertText","parentType","fields","index","insertText","queryVariables","documentText","typeMap","schemaInterfaces","schemaInterfaceNames","name","inlineInterfaces","runOnlineParser","_","_b","_c","_d","_e","interfaceConfig","objectTypeConfig","currentTypeToExtend","siblingInterfaceNames","possibleInterfaces","result","_kind","possibleTypes","abstractType","possibleObjTypes","possibleIfaceMap","iface","namedType","defState","fragments","getFragmentDefinitions","relevantFrags","frag","getParentDefinition","_f","_g","_h","_j","_k","variableName","variableType","definitions","parentDefinition","inputTypeMap","inputTypes","directives","directive","canUseDirective","styleAtCursor","stateAtCursor","stringAtCursor","stream","style","callback","lines","parser","locations","directiveDef","enumValue","fieldDef","inputType","objectTypeDef","objectFieldDefs","interfaceDef","enumType","val","nullableType","objectType","objectField","editor","cur","tokenStart","results","item","onlineParser","initialState","pushRule","getToken","lexRules","parseRules","eatWhitespace","editorConfig","popRule","advanceRule","tabSize","lex","SpecialParseRules","backupState","assign","levels","expected","unsuccessful","to","from","rules","ruleKind","successful","isList","separator","kinds"],"sourceRoot":""}